// Package ipc provides fixture-based tests for IPC framing per CONTRACT_IPC.md.
//
// These tests decode fixtures generated by the real Node executor to validate
// cross-language codec compatibility. The fixture is generated by:
//
//	cd executor-node && npx tsx testdata/generate-e2e-fixture.ts
//
// Per CONTRACT_IPC.md:
//   - Frames use 4-byte big-endian length prefix
//   - Payloads are msgpack-encoded
//   - artifact_chunk frames are discriminated by type field
//   - Terminal events (run_complete, run_error) end the stream
package ipc

import (
	"bytes"
	"encoding/json"
	"errors"
	"io"
	"os"
	"path/filepath"
	"runtime"
	"testing"

	"github.com/justapithecus/quarry/types"
)

// e2eManifest represents the manifest JSON structure.
type e2eManifest struct {
	GeneratedAt            string          `json:"generated_at"`
	RunID                  string          `json:"run_id"`
	FixtureScript          string          `json:"fixture_script"`
	SizeBytes              int             `json:"size_bytes"`
	FrameCount             int             `json:"frame_count"`
	ExpectedEvents         []expectedEvent `json:"expected_events"`
	ExpectedArtifactChunks int             `json:"expected_artifact_chunks"`
	ExitCode               int             `json:"exit_code"`
}

type expectedEvent struct {
	Seq      int    `json:"seq"`
	Type     string `json:"type"`
	ItemType string `json:"item_type,omitempty"`
	Level    string `json:"level,omitempty"`
	Name     string `json:"name,omitempty"`
}

// loadE2EFixture loads the e2e fixture binary.
func loadE2EFixture(t *testing.T) []byte {
	t.Helper()

	_, thisFile, _, ok := runtime.Caller(0)
	if !ok {
		t.Fatal("failed to get caller info")
	}

	fixturePath := filepath.Join(filepath.Dir(thisFile), "testdata", "e2e_fixture.bin")
	data, err := os.ReadFile(fixturePath)
	if err != nil {
		t.Skipf("e2e fixture not found at %s, run: cd executor-node && npx tsx testdata/generate-e2e-fixture.ts", fixturePath)
	}
	return data
}

// loadE2EManifest loads the e2e fixture manifest.
func loadE2EManifest(t *testing.T) *e2eManifest {
	t.Helper()

	_, thisFile, _, ok := runtime.Caller(0)
	if !ok {
		t.Fatal("failed to get caller info")
	}

	manifestPath := filepath.Join(filepath.Dir(thisFile), "testdata", "e2e_fixture.manifest.json")
	data, err := os.ReadFile(manifestPath)
	if err != nil {
		t.Skipf("e2e manifest not found at %s", manifestPath)
	}

	var manifest e2eManifest
	if err := json.Unmarshal(data, &manifest); err != nil {
		t.Fatalf("failed to parse manifest: %v", err)
	}
	return &manifest
}

// TestE2EFixture_FrameCount validates the fixture has the expected frame count.
func TestE2EFixture_FrameCount(t *testing.T) {
	data := loadE2EFixture(t)
	manifest := loadE2EManifest(t)

	decoder := NewFrameDecoder(bytes.NewReader(data))
	frameCount := 0

	for {
		_, err := decoder.ReadFrame()
		if errors.Is(err, io.EOF) {
			break
		}
		if err != nil {
			t.Fatalf("ReadFrame failed at frame %d: %v", frameCount, err)
		}
		frameCount++
	}

	if frameCount != manifest.FrameCount {
		t.Errorf("frame count = %d, want %d (from manifest)", frameCount, manifest.FrameCount)
	}
}

// TestE2EFixture_EventSequence validates event types and ordering.
// Per CONTRACT_IPC.md, the terminal event must be last.
func TestE2EFixture_EventSequence(t *testing.T) {
	data := loadE2EFixture(t)
	manifest := loadE2EManifest(t)

	decoder := NewFrameDecoder(bytes.NewReader(data))

	var events []*types.EventEnvelope
	var chunks []*types.ArtifactChunkFrame

	for {
		payload, err := decoder.ReadFrame()
		if errors.Is(err, io.EOF) {
			break
		}
		if err != nil {
			t.Fatalf("ReadFrame failed: %v", err)
		}

		frame, err := DecodeFrame(payload)
		if err != nil {
			t.Fatalf("DecodeFrame failed: %v", err)
		}

		switch f := frame.(type) {
		case *types.EventEnvelope:
			events = append(events, f)
		case *types.ArtifactChunkFrame:
			chunks = append(chunks, f)
		default:
			t.Fatalf("unexpected frame type: %T", frame)
		}
	}

	// Validate event count (excluding artifact chunks)
	expectedEventCount := len(manifest.ExpectedEvents)
	if len(events) != expectedEventCount {
		t.Errorf("event count = %d, want %d", len(events), expectedEventCount)
	}

	// Validate chunk count
	if len(chunks) != manifest.ExpectedArtifactChunks {
		t.Errorf("chunk count = %d, want %d", len(chunks), manifest.ExpectedArtifactChunks)
	}

	// Validate each event matches manifest
	for i, expected := range manifest.ExpectedEvents {
		if i >= len(events) {
			t.Errorf("missing event at index %d", i)
			continue
		}
		actual := events[i]

		// Validate type
		if string(actual.Type) != expected.Type {
			t.Errorf("events[%d].Type = %q, want %q", i, actual.Type, expected.Type)
		}

		// Validate seq
		if actual.Seq != int64(expected.Seq) {
			t.Errorf("events[%d].Seq = %d, want %d", i, actual.Seq, expected.Seq)
		}

		// Validate type-specific fields
		switch expected.Type {
		case "item":
			if expected.ItemType != "" {
				if itemType, ok := actual.Payload["item_type"].(string); !ok || itemType != expected.ItemType {
					t.Errorf("events[%d].payload.item_type = %v, want %q", i, actual.Payload["item_type"], expected.ItemType)
				}
			}
		case "log":
			if expected.Level != "" {
				if level, ok := actual.Payload["level"].(string); !ok || level != expected.Level {
					t.Errorf("events[%d].payload.level = %v, want %q", i, actual.Payload["level"], expected.Level)
				}
			}
		case "artifact":
			if expected.Name != "" {
				if name, ok := actual.Payload["name"].(string); !ok || name != expected.Name {
					t.Errorf("events[%d].payload.name = %v, want %q", i, actual.Payload["name"], expected.Name)
				}
			}
		}
	}

	// Validate terminal event is last (CONTRACT_IPC.md requirement)
	if len(events) > 0 {
		lastEvent := events[len(events)-1]
		if !lastEvent.Type.IsTerminal() {
			t.Errorf("last event type = %q, want terminal (run_complete or run_error)", lastEvent.Type)
		}
	}
}

// TestE2EFixture_ArtifactChunks validates artifact chunk structure.
// Per CONTRACT_IPC.md:
//   - Chunks have artifact_id, seq, is_last, data
//   - Seq starts at 1
//   - Final chunk has is_last: true
func TestE2EFixture_ArtifactChunks(t *testing.T) {
	data := loadE2EFixture(t)

	decoder := NewFrameDecoder(bytes.NewReader(data))

	var chunks []*types.ArtifactChunkFrame

	for {
		payload, err := decoder.ReadFrame()
		if errors.Is(err, io.EOF) {
			break
		}
		if err != nil {
			t.Fatalf("ReadFrame failed: %v", err)
		}

		frame, err := DecodeFrame(payload)
		if err != nil {
			t.Fatalf("DecodeFrame failed: %v", err)
		}

		if chunk, ok := frame.(*types.ArtifactChunkFrame); ok {
			chunks = append(chunks, chunk)
		}
	}

	if len(chunks) == 0 {
		t.Skip("no artifact chunks in fixture")
	}

	// Group chunks by artifact_id
	byArtifact := make(map[string][]*types.ArtifactChunkFrame)
	for _, chunk := range chunks {
		byArtifact[chunk.ArtifactID] = append(byArtifact[chunk.ArtifactID], chunk)
	}

	// Validate each artifact's chunks
	for artifactID, artifactChunks := range byArtifact {
		t.Run(artifactID, func(t *testing.T) {
			// Validate seq starts at 1 and is monotonic
			for i, chunk := range artifactChunks {
				expectedSeq := int64(i + 1)
				if chunk.Seq != expectedSeq {
					t.Errorf("chunk %d seq = %d, want %d", i, chunk.Seq, expectedSeq)
				}
			}

			// Validate last chunk has is_last: true
			lastChunk := artifactChunks[len(artifactChunks)-1]
			if !lastChunk.IsLast {
				t.Error("last chunk should have is_last: true")
			}

			// Validate non-last chunks have is_last: false
			for i := 0; i < len(artifactChunks)-1; i++ {
				if artifactChunks[i].IsLast {
					t.Errorf("chunk %d should have is_last: false", i)
				}
			}

			// Validate data is not empty
			for i, chunk := range artifactChunks {
				if len(chunk.Data) == 0 {
					t.Errorf("chunk %d has empty data", i)
				}
			}
		})
	}
}

// TestE2EFixture_RunMetadata validates run metadata is consistent.
func TestE2EFixture_RunMetadata(t *testing.T) {
	data := loadE2EFixture(t)
	manifest := loadE2EManifest(t)

	decoder := NewFrameDecoder(bytes.NewReader(data))

	for {
		payload, err := decoder.ReadFrame()
		if errors.Is(err, io.EOF) {
			break
		}
		if err != nil {
			t.Fatalf("ReadFrame failed: %v", err)
		}

		frame, err := DecodeFrame(payload)
		if err != nil {
			t.Fatalf("DecodeFrame failed: %v", err)
		}

		// Only events have run metadata
		env, ok := frame.(*types.EventEnvelope)
		if !ok {
			continue
		}

		// Validate run_id matches manifest
		if env.RunID != manifest.RunID {
			t.Errorf("event run_id = %q, want %q", env.RunID, manifest.RunID)
		}

		// Validate attempt is 1 (from fixture input)
		if env.Attempt != 1 {
			t.Errorf("event attempt = %d, want 1", env.Attempt)
		}

		// Validate contract version is present
		if env.ContractVersion == "" {
			t.Error("event contract_version is empty")
		}
	}
}

// TestE2EFixture_SeqMonotonicity validates seq numbers are monotonically increasing.
// Per CONTRACT_EMIT.md, seq starts at 1 and increases by 1 for each event.
func TestE2EFixture_SeqMonotonicity(t *testing.T) {
	data := loadE2EFixture(t)

	decoder := NewFrameDecoder(bytes.NewReader(data))

	var prevSeq int64 = 0

	for {
		payload, err := decoder.ReadFrame()
		if errors.Is(err, io.EOF) {
			break
		}
		if err != nil {
			t.Fatalf("ReadFrame failed: %v", err)
		}

		frame, err := DecodeFrame(payload)
		if err != nil {
			t.Fatalf("DecodeFrame failed: %v", err)
		}

		// Only events have seq
		env, ok := frame.(*types.EventEnvelope)
		if !ok {
			continue
		}

		// Seq must be strictly greater than previous
		if env.Seq <= prevSeq {
			t.Errorf("seq %d is not greater than previous %d", env.Seq, prevSeq)
		}

		// Seq should increment by 1
		if prevSeq > 0 && env.Seq != prevSeq+1 {
			t.Errorf("seq gap: %d -> %d (expected %d)", prevSeq, env.Seq, prevSeq+1)
		}

		prevSeq = env.Seq
	}

	// First seq should be 1
	if prevSeq > 0 {
		// We processed at least one event, so seq should end at expected count
		manifest := loadE2EManifest(t)
		expectedFinalSeq := int64(len(manifest.ExpectedEvents))
		if prevSeq != expectedFinalSeq {
			t.Errorf("final seq = %d, want %d", prevSeq, expectedFinalSeq)
		}
	}
}
