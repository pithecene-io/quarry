package ipc

import (
	"bytes"
	"io"
	"os"
	"path/filepath"
	"testing"

	"github.com/justapithecus/quarry/types"
)

// TestFixtures validates that Go can decode msgpack frames generated by
// the Node executor. This catches encoding format drift between languages.
//
// Fixtures are generated by: executor-node/scripts/generate-ipc-fixtures.ts
// Regenerate with: cd executor-node && npx tsx scripts/generate-ipc-fixtures.ts

func loadFixture(t *testing.T, name string) []byte {
	t.Helper()
	path := filepath.Join("testdata", name)
	data, err := os.ReadFile(path)
	if err != nil {
		t.Fatalf("failed to load fixture %s: %v", name, err)
	}
	return data
}

func TestFixture_ItemEvent(t *testing.T) {
	data := loadFixture(t, "item_event.bin")
	decoder := NewFrameDecoder(bytes.NewReader(data))

	payload, err := decoder.ReadFrame()
	if err != nil {
		t.Fatalf("ReadFrame failed: %v", err)
	}

	envelope, err := DecodeEventEnvelope(payload)
	if err != nil {
		t.Fatalf("DecodeEventEnvelope failed: %v", err)
	}

	// Validate expected values
	if envelope.Type != types.EventTypeItem {
		t.Errorf("Type = %q, want %q", envelope.Type, types.EventTypeItem)
	}
	if envelope.EventID != "evt-fixture-001" {
		t.Errorf("EventID = %q, want %q", envelope.EventID, "evt-fixture-001")
	}
	if envelope.RunID != "run-fixture-001" {
		t.Errorf("RunID = %q, want %q", envelope.RunID, "run-fixture-001")
	}
	if envelope.Seq != 1 {
		t.Errorf("Seq = %d, want 1", envelope.Seq)
	}
	if envelope.Attempt != 1 {
		t.Errorf("Attempt = %d, want 1", envelope.Attempt)
	}
	if envelope.ContractVersion != "0.1.0" {
		t.Errorf("ContractVersion = %q, want %q", envelope.ContractVersion, "0.1.0")
	}

	// Validate payload structure
	if envelope.Payload == nil {
		t.Fatal("Payload is nil")
	}
	if itemType, ok := envelope.Payload["item_type"].(string); !ok || itemType != "product" {
		t.Errorf("payload.item_type = %v, want %q", envelope.Payload["item_type"], "product")
	}
}

func TestFixture_LogEvent(t *testing.T) {
	data := loadFixture(t, "log_event.bin")
	decoder := NewFrameDecoder(bytes.NewReader(data))

	payload, err := decoder.ReadFrame()
	if err != nil {
		t.Fatalf("ReadFrame failed: %v", err)
	}

	envelope, err := DecodeEventEnvelope(payload)
	if err != nil {
		t.Fatalf("DecodeEventEnvelope failed: %v", err)
	}

	if envelope.Type != types.EventTypeLog {
		t.Errorf("Type = %q, want %q", envelope.Type, types.EventTypeLog)
	}
	if envelope.Seq != 2 {
		t.Errorf("Seq = %d, want 2", envelope.Seq)
	}

	// Validate log payload
	if level, ok := envelope.Payload["level"].(string); !ok || level != "info" {
		t.Errorf("payload.level = %v, want %q", envelope.Payload["level"], "info")
	}
	if message, ok := envelope.Payload["message"].(string); !ok || message != "Processing started" {
		t.Errorf("payload.message = %v, want %q", envelope.Payload["message"], "Processing started")
	}
}

func TestFixture_RunComplete(t *testing.T) {
	data := loadFixture(t, "run_complete.bin")
	decoder := NewFrameDecoder(bytes.NewReader(data))

	payload, err := decoder.ReadFrame()
	if err != nil {
		t.Fatalf("ReadFrame failed: %v", err)
	}

	envelope, err := DecodeEventEnvelope(payload)
	if err != nil {
		t.Fatalf("DecodeEventEnvelope failed: %v", err)
	}

	if envelope.Type != types.EventTypeRunComplete {
		t.Errorf("Type = %q, want %q", envelope.Type, types.EventTypeRunComplete)
	}
	if !envelope.Type.IsTerminal() {
		t.Error("run_complete should be terminal")
	}

	// Validate summary in payload
	summary, ok := envelope.Payload["summary"].(map[string]any)
	if !ok {
		t.Fatalf("payload.summary is not a map: %T", envelope.Payload["summary"])
	}
	// msgpack may decode integers as various types depending on value
	itemsScraped := summary["items_scraped"]
	var itemsValue int64
	switch v := itemsScraped.(type) {
	case int8:
		itemsValue = int64(v)
	case int16:
		itemsValue = int64(v)
	case int32:
		itemsValue = int64(v)
	case int64:
		itemsValue = v
	case uint8:
		itemsValue = int64(v)
	case uint16:
		itemsValue = int64(v)
	case uint32:
		itemsValue = int64(v)
	case uint64:
		itemsValue = int64(v)
	default:
		t.Fatalf("summary.items_scraped has unexpected type: %T", itemsScraped)
	}
	if itemsValue != 42 {
		t.Errorf("summary.items_scraped = %d, want 42", itemsValue)
	}
}

func TestFixture_RunError(t *testing.T) {
	data := loadFixture(t, "run_error.bin")
	decoder := NewFrameDecoder(bytes.NewReader(data))

	payload, err := decoder.ReadFrame()
	if err != nil {
		t.Fatalf("ReadFrame failed: %v", err)
	}

	envelope, err := DecodeEventEnvelope(payload)
	if err != nil {
		t.Fatalf("DecodeEventEnvelope failed: %v", err)
	}

	if envelope.Type != types.EventTypeRunError {
		t.Errorf("Type = %q, want %q", envelope.Type, types.EventTypeRunError)
	}
	if !envelope.Type.IsTerminal() {
		t.Error("run_error should be terminal")
	}

	// Validate error payload
	if errorType, ok := envelope.Payload["error_type"].(string); !ok || errorType != "script_error" {
		t.Errorf("payload.error_type = %v, want %q", envelope.Payload["error_type"], "script_error")
	}
	if message, ok := envelope.Payload["message"].(string); !ok || message != "Failed to load page" {
		t.Errorf("payload.message = %v, want %q", envelope.Payload["message"], "Failed to load page")
	}
	if _, ok := envelope.Payload["stack"].(string); !ok {
		t.Error("payload.stack should be a string")
	}
}

func TestFixture_ArtifactEvent(t *testing.T) {
	data := loadFixture(t, "artifact_event.bin")
	decoder := NewFrameDecoder(bytes.NewReader(data))

	payload, err := decoder.ReadFrame()
	if err != nil {
		t.Fatalf("ReadFrame failed: %v", err)
	}

	envelope, err := DecodeEventEnvelope(payload)
	if err != nil {
		t.Fatalf("DecodeEventEnvelope failed: %v", err)
	}

	if envelope.Type != types.EventTypeArtifact {
		t.Errorf("Type = %q, want %q", envelope.Type, types.EventTypeArtifact)
	}

	// Validate artifact payload
	if artifactID, ok := envelope.Payload["artifact_id"].(string); !ok || artifactID != "art-fixture-001" {
		t.Errorf("payload.artifact_id = %v, want %q", envelope.Payload["artifact_id"], "art-fixture-001")
	}
	if name, ok := envelope.Payload["name"].(string); !ok || name != "screenshot.png" {
		t.Errorf("payload.name = %v, want %q", envelope.Payload["name"], "screenshot.png")
	}
	if contentType, ok := envelope.Payload["content_type"].(string); !ok || contentType != "image/png" {
		t.Errorf("payload.content_type = %v, want %q", envelope.Payload["content_type"], "image/png")
	}
}

func TestFixture_ArtifactChunk(t *testing.T) {
	data := loadFixture(t, "artifact_chunk.bin")
	decoder := NewFrameDecoder(bytes.NewReader(data))

	payload, err := decoder.ReadFrame()
	if err != nil {
		t.Fatalf("ReadFrame failed: %v", err)
	}

	// Use DecodeFrame to discriminate type
	result, err := DecodeFrame(payload)
	if err != nil {
		t.Fatalf("DecodeFrame failed: %v", err)
	}

	chunk, ok := result.(*types.ArtifactChunkFrame)
	if !ok {
		t.Fatalf("expected *types.ArtifactChunkFrame, got %T", result)
	}

	if chunk.Type != "artifact_chunk" {
		t.Errorf("Type = %q, want %q", chunk.Type, "artifact_chunk")
	}
	if chunk.ArtifactID != "art-fixture-001" {
		t.Errorf("ArtifactID = %q, want %q", chunk.ArtifactID, "art-fixture-001")
	}
	if chunk.Seq != 1 {
		t.Errorf("Seq = %d, want 1", chunk.Seq)
	}
	if !chunk.IsLast {
		t.Error("IsLast should be true")
	}
	if len(chunk.Data) == 0 {
		t.Error("Data should not be empty")
	}
}

func TestFixture_EventWithLineage(t *testing.T) {
	data := loadFixture(t, "event_with_lineage.bin")
	decoder := NewFrameDecoder(bytes.NewReader(data))

	payload, err := decoder.ReadFrame()
	if err != nil {
		t.Fatalf("ReadFrame failed: %v", err)
	}

	envelope, err := DecodeEventEnvelope(payload)
	if err != nil {
		t.Fatalf("DecodeEventEnvelope failed: %v", err)
	}

	// Validate lineage fields
	if envelope.Attempt != 2 {
		t.Errorf("Attempt = %d, want 2", envelope.Attempt)
	}
	if envelope.JobID == nil {
		t.Error("JobID should not be nil")
	} else if *envelope.JobID != "job-fixture-001" {
		t.Errorf("JobID = %q, want %q", *envelope.JobID, "job-fixture-001")
	}
	if envelope.ParentRunID == nil {
		t.Error("ParentRunID should not be nil")
	} else if *envelope.ParentRunID != "run-fixture-002" {
		t.Errorf("ParentRunID = %q, want %q", *envelope.ParentRunID, "run-fixture-002")
	}
}

func TestFixture_EventSequence(t *testing.T) {
	data := loadFixture(t, "event_sequence.bin")
	decoder := NewFrameDecoder(bytes.NewReader(data))

	var events []*types.EventEnvelope
	for {
		payload, err := decoder.ReadFrame()
		if err == io.EOF {
			break
		}
		if err != nil {
			t.Fatalf("ReadFrame failed: %v", err)
		}

		envelope, err := DecodeEventEnvelope(payload)
		if err != nil {
			t.Fatalf("DecodeEventEnvelope failed: %v", err)
		}
		events = append(events, envelope)
	}

	if len(events) != 3 {
		t.Fatalf("expected 3 events, got %d", len(events))
	}

	// Verify sequence order
	expectedTypes := []types.EventType{
		types.EventTypeItem,
		types.EventTypeLog,
		types.EventTypeRunComplete,
	}
	for i, expected := range expectedTypes {
		if events[i].Type != expected {
			t.Errorf("events[%d].Type = %q, want %q", i, events[i].Type, expected)
		}
		if events[i].Seq != int64(i+1) {
			t.Errorf("events[%d].Seq = %d, want %d", i, events[i].Seq, i+1)
		}
	}

	// Last event should be terminal
	if !events[len(events)-1].Type.IsTerminal() {
		t.Error("last event should be terminal")
	}
}
